{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data structures relationships made easy Note corm is in early development. API can change. Installation pip install corm Example from corm import Storage , Entity , Nested , Relationship class Address ( Entity ): street : str number : int user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): name : str address : Address = Nested ( entity_type = Address , back_relation = True ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 }}, storage = storage , ) assert john . address . street == 'First' assert john . address . number == 1 assert john . address . user is john","title":"Overview"},{"location":"#installation","text":"pip install corm","title":"Installation"},{"location":"#example","text":"from corm import Storage , Entity , Nested , Relationship class Address ( Entity ): street : str number : int user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): name : str address : Address = Nested ( entity_type = Address , back_relation = True ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 }}, storage = storage , ) assert john . address . street == 'First' assert john . address . number == 1 assert john . address . user is john","title":"Example"},{"location":"benchmarks/","text":"","title":"Benchmarks"},{"location":"faq/","text":"Is corm fast or memory efficiency? Not sure, main goal of corm is convenience not performance Is it validation library? No, corm is about relations between entities. It does nothing for validation.","title":"FAQ"},{"location":"faq/#is-corm-fast-or-memory-efficiency","text":"Not sure, main goal of corm is convenience not performance","title":"Is corm fast or memory efficiency?"},{"location":"faq/#is-it-validation-library","text":"No, corm is about relations between entities. It does nothing for validation.","title":"Is it validation library?"},{"location":"to-be-done/","text":"Entity settings class from corm import Storage , Entity class Address ( Entity ): class Config : exclude = ( 'description' ,) street : str number : int storage = Storage () address = Address ( data = { 'street' : 'Second' , 'number' : 2 , 'description' : 'address' }, storage = storage , ) assert address . dict () == { 'street' : 'Second' , 'number' : 2 } Storage context from corm import Entity , storage_ctx class User ( Entity ): id : int with storage_ctx : user = User ( data = { 'id' : 1 }) Namespaces Right now it is not possible to define few entities with same name, for example there are two files: a.py from corm import Entity class Foo ( Entity ): id : int and same in b.py will cause error from corm import Entity class Foo ( Entity ): id : int Solution from corm import Entity , Namespace namespace1 = Namespace () namespace2 = Namespace () # a.py class Foo ( Entity ): class Config : namespace = namespace1 id : int # b.py class Foo ( Entity ): class Config : namespace = namespace2 id : int Entity migration between different instances of storage from corm import Storage , Entity , Field class User ( Entity ): id : int = Field ( pk = True ) storage1 = Storage () storage2 = Storage () user = User ( data = { 'id' : 1 }, storage = storage1 ) storage2 . merge ( user ) assert storage1 . get ( User . id , 1 ) is None assert storage2 . get ( User . id , 1 ) is user Query API from corm import Storage , Entity class User ( Entity ): name : str storage = Storage () john = User ( data = { 'name' : 'John' }, storage = storage ) user = storage . select ( User ) . filter ( User . name == 'John' ) . first () assert user == john","title":"To Be Done"},{"location":"to-be-done/#entity-settings-class","text":"from corm import Storage , Entity class Address ( Entity ): class Config : exclude = ( 'description' ,) street : str number : int storage = Storage () address = Address ( data = { 'street' : 'Second' , 'number' : 2 , 'description' : 'address' }, storage = storage , ) assert address . dict () == { 'street' : 'Second' , 'number' : 2 }","title":"Entity settings class"},{"location":"to-be-done/#storage-context","text":"from corm import Entity , storage_ctx class User ( Entity ): id : int with storage_ctx : user = User ( data = { 'id' : 1 })","title":"Storage context"},{"location":"to-be-done/#namespaces","text":"Right now it is not possible to define few entities with same name, for example there are two files: a.py from corm import Entity class Foo ( Entity ): id : int and same in b.py will cause error from corm import Entity class Foo ( Entity ): id : int Solution from corm import Entity , Namespace namespace1 = Namespace () namespace2 = Namespace () # a.py class Foo ( Entity ): class Config : namespace = namespace1 id : int # b.py class Foo ( Entity ): class Config : namespace = namespace2 id : int","title":"Namespaces"},{"location":"to-be-done/#entity-migration-between-different-instances-of-storage","text":"from corm import Storage , Entity , Field class User ( Entity ): id : int = Field ( pk = True ) storage1 = Storage () storage2 = Storage () user = User ( data = { 'id' : 1 }, storage = storage1 ) storage2 . merge ( user ) assert storage1 . get ( User . id , 1 ) is None assert storage2 . get ( User . id , 1 ) is user","title":"Entity migration between different instances of storage"},{"location":"to-be-done/#query-api","text":"from corm import Storage , Entity class User ( Entity ): name : str storage = Storage () john = User ( data = { 'name' : 'John' }, storage = storage ) user = storage . select ( User ) . filter ( User . name == 'John' ) . first () assert user == john","title":"Query API"},{"location":"usage/entity/","text":"Base usage You can describe wrappers for data structures with Entity from corm import Storage , Entity class User ( Entity ): id : int name : str description : str = 'cool guy' storage = Storage () john = User ({ 'id' : 1 , 'name' : 'John' , 'address' : 'kirova 1' }, storage ) john . name = 'Not John' assert john . dict () == { 'id' : 1 , 'name' : 'Not John' , 'address' : 'kirova 1' , 'description' : 'cool guy' , } Note You don't need to describe full data structure, only fields you need, rest corm leave as is. In example above address key Fields To set additional settings for any entity fields there is Field class from corm import Storage , Entity , Field class User ( Entity ): id : int = Field ( origin = 'user_id' ) name : str description : str = Field ( default = 'user' ) storage = Storage () user = User ( data = { 'user_id' : 33 , 'name' : 'John' }, storage = storage ) assert user . id == 33 assert user . description == 'user' assert user . dict () == { 'user_id' : 33 , 'name' : 'John' , 'description' : 'user' } Default values There are two ways to set default value, just set as class value or through default param of Field , Nested or KeyNested from corm import Storage , Entity , Field class Foo ( Entity ): inplace = 1 in_field = Field ( default = 2 ) in_field_callable = Field ( default = list ) storage = Storage () foo = Foo ( data = {}, storage = storage ) assert foo . inplace == 1 assert foo . in_field == 2 assert foo . in_field_callable == [] Note default also can be callable, corm call it each time when creating entity instance if value of field is not provided. But you can use it only with Field , Nested or KeyNested , inplace is not allowed from corm import Storage , Entity class Foo ( Entity ): inplace = list storage = Storage () foo = Foo ( data = {}, storage = storage ) assert foo . inplace == list # still callable, not new empty list","title":"Entity"},{"location":"usage/entity/#base-usage","text":"You can describe wrappers for data structures with Entity from corm import Storage , Entity class User ( Entity ): id : int name : str description : str = 'cool guy' storage = Storage () john = User ({ 'id' : 1 , 'name' : 'John' , 'address' : 'kirova 1' }, storage ) john . name = 'Not John' assert john . dict () == { 'id' : 1 , 'name' : 'Not John' , 'address' : 'kirova 1' , 'description' : 'cool guy' , } Note You don't need to describe full data structure, only fields you need, rest corm leave as is. In example above address key","title":"Base usage"},{"location":"usage/entity/#fields","text":"To set additional settings for any entity fields there is Field class from corm import Storage , Entity , Field class User ( Entity ): id : int = Field ( origin = 'user_id' ) name : str description : str = Field ( default = 'user' ) storage = Storage () user = User ( data = { 'user_id' : 33 , 'name' : 'John' }, storage = storage ) assert user . id == 33 assert user . description == 'user' assert user . dict () == { 'user_id' : 33 , 'name' : 'John' , 'description' : 'user' }","title":"Fields"},{"location":"usage/entity/#default-values","text":"There are two ways to set default value, just set as class value or through default param of Field , Nested or KeyNested from corm import Storage , Entity , Field class Foo ( Entity ): inplace = 1 in_field = Field ( default = 2 ) in_field_callable = Field ( default = list ) storage = Storage () foo = Foo ( data = {}, storage = storage ) assert foo . inplace == 1 assert foo . in_field == 2 assert foo . in_field_callable == [] Note default also can be callable, corm call it each time when creating entity instance if value of field is not provided. But you can use it only with Field , Nested or KeyNested , inplace is not allowed from corm import Storage , Entity class Foo ( Entity ): inplace = list storage = Storage () foo = Foo ( data = {}, storage = storage ) assert foo . inplace == list # still callable, not new empty list","title":"Default values"},{"location":"usage/hooks/","text":"Simple example import typing as t from corm import Storage , Entity , Nested , Hook , HookContext storage = Storage () class Address ( Entity ): id : int street : str number : int class User ( Entity ): id : int name : str address : Address = Nested ( entity_type = Address ) class ExcludeHook ( Hook ): match_entities = [ User , Address ] def __init__ ( self , exclude_fields : t . List [ str ], match_entities = None ): super () . __init__ ( match_entities ) self . exclude_fields = exclude_fields def match ( self , data , context : HookContext ): for field in self . exclude_fields : data . pop ( field , None ) return data john = User ( data = { 'id' : 1 , 'name' : 'John' , 'address' : { 'id' : 2 , 'street' : 'First' , 'number' : 1 }, }, storage = storage , ) assert john . dict ( hooks = [ ExcludeHook ( exclude_fields = [ 'id' ])]) == { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 }, }","title":"Hooks"},{"location":"usage/hooks/#simple-example","text":"import typing as t from corm import Storage , Entity , Nested , Hook , HookContext storage = Storage () class Address ( Entity ): id : int street : str number : int class User ( Entity ): id : int name : str address : Address = Nested ( entity_type = Address ) class ExcludeHook ( Hook ): match_entities = [ User , Address ] def __init__ ( self , exclude_fields : t . List [ str ], match_entities = None ): super () . __init__ ( match_entities ) self . exclude_fields = exclude_fields def match ( self , data , context : HookContext ): for field in self . exclude_fields : data . pop ( field , None ) return data john = User ( data = { 'id' : 1 , 'name' : 'John' , 'address' : { 'id' : 2 , 'street' : 'First' , 'number' : 1 }, }, storage = storage , ) assert john . dict ( hooks = [ ExcludeHook ( exclude_fields = [ 'id' ])]) == { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 }, }","title":"Simple example"},{"location":"usage/key-relationships/","text":"Simple case from corm import Storage , Entity , KeyNested , Field class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str class EntityHolder ( Entity ): name : str entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , ) storage = Storage () entity = SomeEntity ({ 'id' : 123 , 'name' : 'entity' }, storage = storage ) holder = EntityHolder ({ 'entity_id' : 123 }, storage = storage ) assert holder . entity == entity Bidirectional key relationships from corm import ( Storage , Field , Entity , KeyNested , Relationship , ) class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str holder : 'EntityHolder' = Relationship ( entity_type = 'EntityHolder' ) class EntityHolder ( Entity ): name : str entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , back_relation = True , ) storage = Storage () entity = SomeEntity ({ 'id' : 123 , 'name' : 'entity' }, storage = storage ) holder = EntityHolder ({ 'name' : 'holder' , 'entity_id' : 123 }, storage = storage ) assert holder . entity == entity assert entity . holder == holder Change relationships between entities As with Nested it is possible to change related data from corm import Relationship , Entity , Field , KeyNested , Storage class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str holder : 'EntityHolder' = Relationship ( entity_type = 'EntityHolder' ) class EntityHolder ( Entity ): entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , back_relation = True , ) storage = Storage () entity1 = SomeEntity ({ 'id' : 123 , 'name' : 'entity1' }, storage = storage ) entity2 = SomeEntity ({ 'id' : 321 , 'name' : 'entity2' }, storage = storage ) holder = EntityHolder ( data = { 'entity_id' : 123 }, storage = storage , ) holder . entity = entity2 assert entity1 . holder is None assert entity2 . holder is holder assert holder . entity is entity2 assert holder . dict () == { 'entity_id' : 321 }","title":"Key relationships"},{"location":"usage/key-relationships/#simple-case","text":"from corm import Storage , Entity , KeyNested , Field class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str class EntityHolder ( Entity ): name : str entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , ) storage = Storage () entity = SomeEntity ({ 'id' : 123 , 'name' : 'entity' }, storage = storage ) holder = EntityHolder ({ 'entity_id' : 123 }, storage = storage ) assert holder . entity == entity","title":"Simple case"},{"location":"usage/key-relationships/#bidirectional-key-relationships","text":"from corm import ( Storage , Field , Entity , KeyNested , Relationship , ) class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str holder : 'EntityHolder' = Relationship ( entity_type = 'EntityHolder' ) class EntityHolder ( Entity ): name : str entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , back_relation = True , ) storage = Storage () entity = SomeEntity ({ 'id' : 123 , 'name' : 'entity' }, storage = storage ) holder = EntityHolder ({ 'name' : 'holder' , 'entity_id' : 123 }, storage = storage ) assert holder . entity == entity assert entity . holder == holder","title":"Bidirectional key relationships"},{"location":"usage/key-relationships/#change-relationships-between-entities","text":"As with Nested it is possible to change related data from corm import Relationship , Entity , Field , KeyNested , Storage class SomeEntity ( Entity ): id : int = Field ( pk = True ) name : str holder : 'EntityHolder' = Relationship ( entity_type = 'EntityHolder' ) class EntityHolder ( Entity ): entity : SomeEntity = KeyNested ( related_entity_field = SomeEntity . id , origin = 'entity_id' , back_relation = True , ) storage = Storage () entity1 = SomeEntity ({ 'id' : 123 , 'name' : 'entity1' }, storage = storage ) entity2 = SomeEntity ({ 'id' : 321 , 'name' : 'entity2' }, storage = storage ) holder = EntityHolder ( data = { 'entity_id' : 123 }, storage = storage , ) holder . entity = entity2 assert entity1 . holder is None assert entity2 . holder is holder assert holder . entity is entity2 assert holder . dict () == { 'entity_id' : 321 }","title":"Change relationships between entities"},{"location":"usage/relationships/","text":"Simple relationship from corm import Storage , Entity , Nested class Address ( Entity ): street : str number : int class User ( Entity ): name : str address : Address = Nested ( entity_type = Address ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 , }, }, storage = storage , ) assert john . address . street == 'First' assert john . address . number == 1 Bidirectional relationships from corm import Storage , Entity , Relationship , Nested class Address ( Entity ): street : str number : int user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): name : str address : Address = Nested ( entity_type = Address , back_relation = True , ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 , }, }, storage = storage , ) assert john . address . user == john Self-nested import typing as t from corm import Storage , Entity , Relationship , Nested class Item ( Entity ): id : int items : t . List [ 'Item' ] = Nested ( entity_type = 'Item' , back_relation = True , many = True , default = list , ) parent : 'Item' = Relationship ( entity_type = 'Item' ) storage = Storage () item1 = Item ({ 'id' : 1 , 'items' : [{ 'id' : 2 }, { 'id' : 3 }]}, storage ) item2 , item3 = item1 . items assert item1 . id == 1 assert item1 . parent is None assert item2 . id == 2 assert item2 . parent == item1 assert item2 . items == [] assert item3 . id == 3 assert item3 . parent == item1 assert item3 . items == [] Change relationships between entities from corm import Entity , Relationship , Nested , Storage class Address ( Entity ): street : str user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): id : int address : Address = Nested ( entity_type = Address , back_relation = True , ) storage = Storage () john = User ( data = { 'id' : 1 , 'name' : 'John' , 'description' : 'john smith' , 'address' : { 'street' : 'kirova' , }, }, storage = storage , ) old_address = john . address assert old_address . user is john address = Address ( data = { 'street' : 'lenina' }, storage = storage ) john . address = address assert old_address . user is None assert address . user == john assert john . address is address Also it works with many=True import typing as t from corm import Entity , Relationship , Nested , Storage class Address ( Entity ): street : str user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): id : int addresses : t . List [ Address ] = Nested ( entity_type = Address , back_relation = True , many = True , ) storage = Storage () john = User ( data = { 'id' : 1 , 'name' : 'John' , 'description' : 'john smith' , 'addresses' : [ { 'street' : 'kirova 1' , }, { 'street' : 'kirova 2' , }, ], }, storage = storage , ) old_address1 , old_address2 = john . addresses # you can change existing list john . addresses . remove ( old_address1 ) assert old_address1 . user is None assert old_address2 . user is john john . addresses . clear () assert old_address1 . user is None assert old_address2 . user is None assert john . addresses == [] new_address1 = Address ( data = { 'street' : 'lenina 1' }, storage = storage ) new_address2 = Address ( data = { 'street' : 'lenina 2' }, storage = storage ) john . addresses . append ( new_address1 ) assert new_address1 . user is john assert john . addresses == [ new_address1 ] john . addresses . extend ([ new_address2 ]) assert new_address2 . user is john assert john . addresses == [ new_address1 , new_address2 ] # or completely replace it john . addresses = [ old_address1 ] assert new_address1 . user is None assert new_address2 . user is None assert old_address1 . user is john Note As you can see it changes both user and address, but keep in mind it is possible to change relationship through Nested but not through Relationship . In this example address.user = user will raise ValueError Manually related entities It is not common case but is is able to use this way from corm import Storage , Entity , Relationship , RelationType storage = Storage () class Address ( Entity ): street : str number : int class User ( Entity ): name : str address : Address = Relationship ( entity_type = Address , relation_type = RelationType . PARENT , ) address = Address ({ 'street' : 'First' , 'number' : 1 }, storage ) john = User ({ 'name' : 'John' }, storage ) storage . make_relation ( from_ = john , to_ = address , relation_type = RelationType . PARENT , ) assert john . address == address","title":"Relationships"},{"location":"usage/relationships/#simple-relationship","text":"from corm import Storage , Entity , Nested class Address ( Entity ): street : str number : int class User ( Entity ): name : str address : Address = Nested ( entity_type = Address ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 , }, }, storage = storage , ) assert john . address . street == 'First' assert john . address . number == 1","title":"Simple relationship"},{"location":"usage/relationships/#bidirectional-relationships","text":"from corm import Storage , Entity , Relationship , Nested class Address ( Entity ): street : str number : int user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): name : str address : Address = Nested ( entity_type = Address , back_relation = True , ) storage = Storage () john = User ( data = { 'name' : 'John' , 'address' : { 'street' : 'First' , 'number' : 1 , }, }, storage = storage , ) assert john . address . user == john","title":"Bidirectional relationships"},{"location":"usage/relationships/#self-nested","text":"import typing as t from corm import Storage , Entity , Relationship , Nested class Item ( Entity ): id : int items : t . List [ 'Item' ] = Nested ( entity_type = 'Item' , back_relation = True , many = True , default = list , ) parent : 'Item' = Relationship ( entity_type = 'Item' ) storage = Storage () item1 = Item ({ 'id' : 1 , 'items' : [{ 'id' : 2 }, { 'id' : 3 }]}, storage ) item2 , item3 = item1 . items assert item1 . id == 1 assert item1 . parent is None assert item2 . id == 2 assert item2 . parent == item1 assert item2 . items == [] assert item3 . id == 3 assert item3 . parent == item1 assert item3 . items == []","title":"Self-nested"},{"location":"usage/relationships/#change-relationships-between-entities","text":"from corm import Entity , Relationship , Nested , Storage class Address ( Entity ): street : str user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): id : int address : Address = Nested ( entity_type = Address , back_relation = True , ) storage = Storage () john = User ( data = { 'id' : 1 , 'name' : 'John' , 'description' : 'john smith' , 'address' : { 'street' : 'kirova' , }, }, storage = storage , ) old_address = john . address assert old_address . user is john address = Address ( data = { 'street' : 'lenina' }, storage = storage ) john . address = address assert old_address . user is None assert address . user == john assert john . address is address Also it works with many=True import typing as t from corm import Entity , Relationship , Nested , Storage class Address ( Entity ): street : str user : 'User' = Relationship ( entity_type = 'User' ) class User ( Entity ): id : int addresses : t . List [ Address ] = Nested ( entity_type = Address , back_relation = True , many = True , ) storage = Storage () john = User ( data = { 'id' : 1 , 'name' : 'John' , 'description' : 'john smith' , 'addresses' : [ { 'street' : 'kirova 1' , }, { 'street' : 'kirova 2' , }, ], }, storage = storage , ) old_address1 , old_address2 = john . addresses # you can change existing list john . addresses . remove ( old_address1 ) assert old_address1 . user is None assert old_address2 . user is john john . addresses . clear () assert old_address1 . user is None assert old_address2 . user is None assert john . addresses == [] new_address1 = Address ( data = { 'street' : 'lenina 1' }, storage = storage ) new_address2 = Address ( data = { 'street' : 'lenina 2' }, storage = storage ) john . addresses . append ( new_address1 ) assert new_address1 . user is john assert john . addresses == [ new_address1 ] john . addresses . extend ([ new_address2 ]) assert new_address2 . user is john assert john . addresses == [ new_address1 , new_address2 ] # or completely replace it john . addresses = [ old_address1 ] assert new_address1 . user is None assert new_address2 . user is None assert old_address1 . user is john Note As you can see it changes both user and address, but keep in mind it is possible to change relationship through Nested but not through Relationship . In this example address.user = user will raise ValueError","title":"Change relationships between entities"},{"location":"usage/relationships/#manually-related-entities","text":"It is not common case but is is able to use this way from corm import Storage , Entity , Relationship , RelationType storage = Storage () class Address ( Entity ): street : str number : int class User ( Entity ): name : str address : Address = Relationship ( entity_type = Address , relation_type = RelationType . PARENT , ) address = Address ({ 'street' : 'First' , 'number' : 1 }, storage ) john = User ({ 'name' : 'John' }, storage ) storage . make_relation ( from_ = john , to_ = address , relation_type = RelationType . PARENT , ) assert john . address == address","title":"Manually related entities"},{"location":"usage/storage/","text":"","title":"Storage"}]}